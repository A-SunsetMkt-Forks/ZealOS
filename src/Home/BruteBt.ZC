/*
public _intern IC_BT				Bool Bt(		  U8 *bit_field, I64 bit); //Bit test.
public _intern IC_BTR				Bool Btr(		  U8 *bit_field, I64 bit); //Bit test and reset to zero.
public _intern IC_BTS				Bool Bts(		  U8 *bit_field, I64 bit); //Bit test and set to one.

*/


/*
$FG$$BG$$FG,11$
Bool BruteBt(U8 *bit_field, I64 bit)
{
	U8 *chunk = bit_field + (bit / 8);

	return *chunk & (1 << (bit % 8));
}


Reg/Offset Symbol$FG$
       R10 bit_field
       RDI bit
       RSI chunk
FFFFFFFFF8 Stack Size
$FG,11$        &Function+Offset Machine Code   Instruction  Operands$FG$$HL,1$
$LK,"&BruteBt+0x0000",A="FL:C:/Home/TEST.ZC,8"$
         &BruteBt+0x0000 0x55           PUSH         U64 RBP
         &BruteBt+0x0001 0x488BEC       MOV          U64 RBP, U64 RSP
         &BruteBt+0x0004 0x4883EC08     SUB          U64 RSP, I8 0x08
         &BruteBt+0x0008 0x56           PUSH         U64 RSI
         &BruteBt+0x0009 0x57           PUSH         U64 RDI
         &BruteBt+0x000A 0x4952         PUSH         U64 R10
         &BruteBt+0x000C 0x488B7D18     MOV          U64 RDI, U64 0x18[RBP]
         &BruteBt+0x0010 0x4C8B5510     MOV          U64 R10, U64 0x10[RBP]
$LK,"&BruteBt+0x0014",A="FL:C:/Home/TEST.ZC,10"$
         &BruteBt+0x0014 0x488BC7       MOV          U64 RAX, U64 RDI
         &BruteBt+0x0017 0x48C1F803     SAR          U64 RAX, U8 0x03
         &BruteBt+0x001B 0x488BF0       MOV          U64 RSI, U64 RAX
         &BruteBt+0x001E 0x4903F2       ADD          U64 RSI, U64 R10
$LK,"&BruteBt+0x0021",A="FL:C:/Home/TEST.ZC,12"$
         &BruteBt+0x0021 0x33C9         XOR          U64 RCX, U64 RCX
         &BruteBt+0x0023 0xB108         MOV          U8 CL, I8 0x08
         &BruteBt+0x0025 0x488BC7       MOV          U64 RAX, U64 RDI
         &BruteBt+0x0028 0x4899         CQO
         &BruteBt+0x002A 0x48F7F9       IDIV         U64 RCX
         &BruteBt+0x002D 0x488BC2       MOV          U64 RAX, U64 RDX
         &BruteBt+0x0030 0x488BC8       MOV          U64 RCX, U64 RAX
         &BruteBt+0x0033 0x33C0         XOR          U64 RAX, U64 RAX
         &BruteBt+0x0035 0xB001         MOV          U8 AL, I8 0x01
         &BruteBt+0x0037 0x48D3E0       SHL          U64 RAX, U8 CL
         &BruteBt+0x003A 0x480FB60E     MOVZX        U64 RCX, U8 [RSI]
         &BruteBt+0x003E 0x4823C1       AND          U64 RAX, U64 RCX
$LK,"&BruteBt+0x0041",A="FL:C:/Home/TEST.ZC,14"$
         &BruteBt+0x0041 0x495A         POP          U64 R10
         &BruteBt+0x0043 0x5F           POP          U64 RDI
         &BruteBt+0x0044 0x5E           POP          U64 RSI
         &BruteBt+0x0045 0xC9           LEAVE
         &BruteBt+0x0046 0xC21000       RET1         I16 0x0010
Code Size:0049
*/

Bool BruteBt(U8 *bit_field, I64 bit)
{
	U8 *chunk = bit_field + (bit / 8);
	U64 chunk_bit = 1 << (bit % 8);

	return (*chunk & chunk_bit) >> (bit % 8);
}

Bool BruteBtr(U8 *bit_field, I64 bit)
{
	U8	*chunk = bit_field + (bit / 8);
	U64 chunk_bit = 1 << (bit % 8);
	Bool result  = (*chunk & chunk_bit) >> (bit % 8);

	*chunk &= ~(chunk_bit);

	return result;
}

Bool BruteBts(U8 *bit_field, I64 bit)
{
	U8	*chunk = bit_field + (bit / 8);
	U64 chunk_bit = 1 << (bit % 8);
	Bool result = (*chunk & chunk_bit) >> (bit % 8);

	*chunk |= chunk_bit;

	return result;
}


U64 numba = 0x982734AABD;

U0 Test1()
{
	I64 i = 10*8;
	"\n\n\n";

	while (i--)
	{
		if (Bt(&numba, i))
			"%d, ", i;
	}

	"\n\n\n";

}

U0 Test2()
{
	I64 i = 10*8;
	"\n\n\n";

	while (i--)
	{
		if (BruteBt(&numba, i))
			"%d, ", i;
	}

	"\n\n\n";

}
